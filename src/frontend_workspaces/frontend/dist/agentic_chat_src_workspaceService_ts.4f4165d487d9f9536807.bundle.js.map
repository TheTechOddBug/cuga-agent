{"version":3,"file":"agentic_chat_src_workspaceService_ts.4f4165d487d9f9536807.bundle.js","mappings":"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","sources":["webpack://@carbon/ai-chat-examples-web-components-basic/../agentic_chat/src/workspaceService.ts"],"sourcesContent":["// Shared workspace service with enforced throttling\n// Ensures /api/workspace/tree is NEVER called more frequently than once per 3 seconds\n\ninterface FileNode {\n  name: string;\n  path: string;\n  type: 'file' | 'directory';\n  children?: FileNode[];\n}\n\ninterface WorkspaceData {\n  tree: FileNode[];\n  timestamp: number;\n}\n\nclass WorkspaceService {\n  private static instance: WorkspaceService;\n  private lastFetchTime: number = 0;\n  private cachedData: WorkspaceData | null = null;\n  private pendingRequest: Promise<WorkspaceData> | null = null;\n  private readonly MIN_INTERVAL_MS = 3000; // 3 seconds minimum between requests\n  private listeners: Set<(data: WorkspaceData) => void> = new Set();\n\n  private constructor() {}\n\n  static getInstance(): WorkspaceService {\n    if (!WorkspaceService.instance) {\n      WorkspaceService.instance = new WorkspaceService();\n    }\n    return WorkspaceService.instance;\n  }\n\n  /**\n   * Subscribe to workspace updates\n   */\n  subscribe(callback: (data: WorkspaceData) => void): () => void {\n    this.listeners.add(callback);\n    // Immediately send cached data if available\n    if (this.cachedData) {\n      callback(this.cachedData);\n    }\n    // Return unsubscribe function\n    return () => {\n      this.listeners.delete(callback);\n    };\n  }\n\n  /**\n   * Notify all subscribers of new data\n   */\n  private notifyListeners(data: WorkspaceData): void {\n    this.listeners.forEach(callback => {\n      try {\n        callback(data);\n      } catch (error) {\n        console.error('Error in workspace listener:', error);\n      }\n    });\n  }\n\n  /**\n   * Fetch workspace tree with enforced throttling\n   * Returns cached data if called too soon after last fetch\n   */\n  async getWorkspaceTree(forceRefresh: boolean = false): Promise<WorkspaceData> {\n    const now = Date.now();\n    const timeSinceLastFetch = now - this.lastFetchTime;\n\n    // If we have cached data and haven't exceeded the minimum interval, return cache\n    if (!forceRefresh && this.cachedData && timeSinceLastFetch < this.MIN_INTERVAL_MS) {\n      return this.cachedData;\n    }\n\n    // If there's already a pending request, wait for it instead of making a new one\n    if (this.pendingRequest) {\n      return this.pendingRequest;\n    }\n\n    // Enforce minimum interval even for forced refresh\n    if (timeSinceLastFetch < this.MIN_INTERVAL_MS) {\n      const waitTime = this.MIN_INTERVAL_MS - timeSinceLastFetch;\n      await new Promise(resolve => setTimeout(resolve, waitTime));\n    }\n\n    // Make the actual request\n    this.pendingRequest = this.fetchWorkspaceData();\n    \n    try {\n      const data = await this.pendingRequest;\n      this.cachedData = data;\n      this.lastFetchTime = Date.now();\n      this.notifyListeners(data);\n      return data;\n    } finally {\n      this.pendingRequest = null;\n    }\n  }\n\n  /**\n   * Internal method to actually fetch data from the API\n   */\n  private async fetchWorkspaceData(): Promise<WorkspaceData> {\n    try {\n      const response = await fetch('/api/workspace/tree');\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      return {\n        tree: data.tree || [],\n        timestamp: Date.now()\n      };\n    } catch (error) {\n      console.error('Error fetching workspace tree:', error);\n      // Return cached data if available, otherwise return empty tree\n      if (this.cachedData) {\n        return this.cachedData;\n      }\n      return { tree: [], timestamp: Date.now() };\n    }\n  }\n\n  /**\n   * Get cached data without making a request\n   */\n  getCachedData(): WorkspaceData | null {\n    return this.cachedData;\n  }\n\n  /**\n   * Clear the cache (useful for testing)\n   */\n  clearCache(): void {\n    this.cachedData = null;\n    this.lastFetchTime = 0;\n  }\n}\n\n// Export singleton instance\nexport const workspaceService = WorkspaceService.getInstance();\nexport type { FileNode, WorkspaceData };\n\n\n\n\n\n"],"names":["WorkspaceService","lastFetchTime","cachedData","pendingRequest","MIN_INTERVAL_MS","listeners","Set","constructor","getInstance","instance","subscribe","callback","add","delete","notifyListeners","data","forEach","error","console","getWorkspaceTree","forceRefresh","now","Date","timeSinceLastFetch","waitTime","Promise","resolve","setTimeout","fetchWorkspaceData","response","fetch","ok","Error","status","json","tree","timestamp","getCachedData","clearCache","workspaceService"],"sourceRoot":""}